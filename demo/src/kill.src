[ . x86 ]

Magic:
	90

Start:
	# Gather argc and skip argv[0].
	5d					# pop rbp
	5e					# pop rsi

	# Abort if argc is less than 3.
	83 fd 03				# cmp 3 ebp
	7c [ rel8 Abort ]			# jl Abort

Parse:
	# Decrement argc, and exit if it's 0.
	ff cd					# dec ebp
	74 [ rel8 Quit ]			# jz Quit

	# Clear the numeric buffers.
	31 c0					# xor eax eax
	99					# cdq

	# Parse the next argument.
	5e					# pop rsi

	# Is it a signal number?
	ac					# lodsb
	3c 2d					# cmp '-' al
	74 [ rel8 ParseSignalNumber ]		# je ParseSignalNumber

ParseProcessID:
	# Gather a process identifier.
	e8 [ rel32 ParseNumber ]		# call ParseNumber
	89 d3					# mov edx ebx

	# Kill process, and continue parsing.
	e8 [ rel32 Kill ]			# call Kill
	eb [ rel8 Parse ]			# jmp Parse

ParseSignalNumber:
	# Gather the signal number.
	e8 [ rel32 ParseNextDigit ]		# call ParseNextDigit
	89 d1					# mov edx ecx

	# Continue parsing.
	eb [ rel8 Parse ]			# jmp Parse

ParseNextDigit:
	# Get the next character.
	ac					# lodsb

ParseNumber:
	# NUL terminator?
	84 c0					# test al al
	74 [ rel8 Return ]			# jz Return

	# Abort if not a digit.
	2c 30					# sub '0' al
	3c 09					# cmp 9 al
	77 [ rel8 Abort ]			# ja Abort

	# Buffer digit.
	6b d2 0a				# imul 10 edx
	03 d0					# add eax edx

	# Continue.
	eb [ rel8 ParseNextDigit ]		# jmp ParseNextDigit

Kill:
	# kill(pid, signal);
	89 ce					# mov ecx rsi
	89 df					# mov ebx edi
	6a 3e 58				# mov SYS_KILL rax
	0f 05					# syscall

Return:
	c3					# ret

Quit:
	# exit(EXIT_SUCCESS);
	6a 00					# push EXIT_SUCCESS
	eb [ rel8 Exit ]			# jmp Exit

Abort:
	# exit(EXIT_FAILURE);
	6a 01					# push EXIT_FAILURE

Exit:
	5f					# pop rdi
	6a 3c 58				# mov SYS_EXIT rax
	0f 05					# syscall
